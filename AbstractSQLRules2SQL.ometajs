var sbvrTypes = require('@resin/sbvr-types'),
	_ = require('lodash');

var comparisons = {
	'Equals': ' = ',
	'GreaterThan': ' > ',
	'GreaterThanOrEqual': ' >= ',
	'LessThan': ' < ',
	'LessThanOrEqual': ' <= ',
	'NotEquals': ' != ',
	'Like': ' LIKE '
};

var fractionalSecondsFormat = function(date) {
	return this['Totalseconds'](date) + ' - ' + this['Second'](date);
};
var websqlBasicDateFormat = function(format) {
	return function(date) {
		return "STRFTIME('" + format + "', " + date + ')';
	};
};
var websqlDateFormats = {
	'Year': websqlBasicDateFormat('%Y'),
	'Month': websqlBasicDateFormat('%m'),
	'Day': websqlBasicDateFormat('%d'),
	'Hour': websqlBasicDateFormat('%H'),
	'Minute': websqlBasicDateFormat('%M'),
	'Second': websqlBasicDateFormat('%S'),
	'Fractionalseconds': fractionalSecondsFormat,
	'Totalseconds': websqlBasicDateFormat('%f')
};

var basicDateFormat = function(part) {
	return function(date) {
		return "EXTRACT('" + part + "' FROM " + date + ')';
	};
};
var dateFormats = {
	'Year': basicDateFormat('YEAR'),
	'Month': basicDateFormat('MONTH'),
	'Day': basicDateFormat('DAY'),
	'Hour': basicDateFormat('HOUR'),
	'Minute': basicDateFormat('MINUTE'),
	'Second': function(date) {
		return 'FLOOR(' + dateFormats['Totalseconds'](date) + ')';
	},
	'Fractionalseconds': fractionalSecondsFormat,
	'Totalseconds': basicDateFormat('SECOND')
};

export ometa AbstractSQLRules2SQL {
	NestedIndent :indent =
		-> (indent + '\t'),

	SelectQuery :indent =
		NestedIndent(indent):nestedIndent
		(
			[	'UnionQuery'
				SelectQuery(nestedIndent):first
				SelectQuery(nestedIndent)+:rest
			]
			-> [first].concat(rest).join(indent + 'UNION' + indent)
		|	{[]}:tables
			{''}:where
			{''}:groupBy
			{''}:orderBy
			{''}:limit
			{''}:offset
			[	'SelectQuery'
				[	Select(indent):fields
				|	Table(indent):table
					{tables.push(table)}
				|	Where(indent):where
					{indent + where}:where
				|	GroupBy(indent):groupBy
					{indent + groupBy}:groupBy
				|	OrderBy(indent):orderBy
					{indent + orderBy}:orderBy
				|	Limit(indent):limit
					{indent + limit}:limit
				|	Offset(indent):offset
					{indent + offset}:offset
				]*
			]
			(	?tables.length
				-> (indent + 'FROM ' + tables.join(',' + nestedIndent))
			|	-> ''
			):from
			-> ('SELECT ' + fields.join(', ') + from + where + groupBy + orderBy + limit + offset)
		),

	DeleteQuery :indent =
		{[]}:tables
		{''}:where
		[	'DeleteQuery'
			[	Table(indent):table
				{tables.push(table)}
			|	Where(indent):where
				{indent + where}:where
			]*
		]
		-> ('DELETE FROM ' + tables.join(', ') + where),

	UpsertQuery :indent =
		[	'UpsertQuery'
			InsertQuery(indent):insert
			{{query: insert, bindings: this.fieldOrderings}}:insert
			{this.fieldOrderings = []}
			UpdateQuery(indent):update
			{{query: update, bindings: this.fieldOrderings}}:update
		]
		-> [insert, update],

	InsertQuery :indent =
		[	'InsertQuery'
			InsertBody(indent):insert
		]
		-> insert,

	UpdateQuery :indent =
		[	'UpdateQuery'
			UpdateBody(indent):update
		]
		-> update,

	InsertBody :indent =
		{[]}:tables
		[	Fields:fields
		|	Values(indent):values
		|	Table(indent):table
			{tables.push(table)}
		]*
		(	?(fields.length > 0)
			(	?(_.isArray(values))
				{'VALUES (' + values.join(', ') + ')'}:values
			)?
			-> ('INSERT INTO ' + tables.join(', ') + ' (' + fields.join(', ') + ')' + indent + values)
		|	-> ('INSERT INTO ' + tables.join(', ') + ' DEFAULT VALUES')
		),

	UpdateBody :indent =
		{[]}:tables
		{''}:where
		[	Fields:fields
			?(fields.length > 0)
		|	Values:values
			?(values.length > 0)
		|	Table(indent):table
			{tables.push(table)}
		|	Where(indent):where
			{indent + where}:where
		]*
		{[]}:sets
		{	for(var i=0; i < fields.length; i++) {
				sets[i] = fields[i] + ' = ' + values[i];
			}
		}
		NestedIndent(indent):nestedIndent
		-> ('UPDATE ' + tables.join(', ') + indent + 'SET ' + sets.join(',' + nestedIndent) + where),

	Fields =
		'Fields'
		{[]}:fields
		[	(	anything:field
				-> ('"' + field + '"')
			)*:fields
		]
		-> fields,

	Values :indent =
		'Values'
		(	SelectQuery(indent):values
		|	[	(	'?'
				|	true
					-> 1
				|	false
					-> 0
				|	Null
				|	Bind
				|	Default
				|	Text
				|	Number
				)*:values
			]
		)
		-> values,

	Default =
		'Default'
		-> 'DEFAULT',

	Select :indent =
		'Select'
		[	end
			{['1']}:fields
		|	(	[	(	SelectField(indent):field
						anything:as
						-> (field + ' AS "' + as + '"')
					|	'Count'
						'*'
						-> 'COUNT(*)'
					|	:table
						'*'
						-> ('"' + table + '".*')
					|	AnyValue(indent):value
						anything:as
						-> (value + ' AS "' + as + '"')
					):field
				]
				-> field
			|	AnyValue(indent)
			|	'*'
			|	Null
			)*:fields
		]
		-> fields,

	SelectField :indent =
			Count
		|	AnyValue(indent)
		|	Null,

	Count =
		[	'Count'
			'*'
		]
		-> 'COUNT(*)',

	Table :indent =
		'From'
		NestedIndent(indent):nestedindent
		(	~string
			[	(	SelectQuery(nestedindent):query
					-> ('(' + nestedindent + query + indent + ')')
				|	anything:table
					(	?(!_.isNull(this.namespace))
						-> ('"' + this.namespace + '"."' + table + '"')
					|	-> ('"' + table + '"')
				 	)
				):from
				anything:alias
			]
			-> (from + ' AS "' + alias + '"')
		|	SelectQuery(nestedindent):query
			-> ('(' + nestedindent + query + indent + ')')
		|	anything:table
			(	?(!_.isNull(this.namespace))
				-> ('"' + this.namespace + '"."' + table + '"')
			|	-> ('"' + table + '"')
			)
		),

	Where :indent =
		'Where'
		BooleanValue(indent):ruleBody
		-> ('WHERE ' + ruleBody),

	GroupBy :indent =
		'GroupBy'
		[	AnyValue(indent)+:values
		]
		-> ('GROUP BY ' + values.join(', ')),

	OrderBy :indent =
		'OrderBy'
		(	[	(	'ASC'
				|	'DESC'
				):order
				Field:field
			]
			-> (field + ' ' + order)
		)+:orders
		NestedIndent(indent):nestedIndent
		-> ('ORDER BY ' + orders.join(',' + nestedIndent)),

	Limit :indent =
		'Limit'
		NumericValue(indent):num
		-> ('LIMIT ' + num),

	Offset :indent =
		'Offset'
		NumericValue(indent):num
		-> ('OFFSET ' + num),

	AnyValue :indent =
		(	UnknownValue(indent)
		|	TextValue(indent)
		|	NumericValue(indent)
		|	BooleanValue(indent)
		|	DateValue(indent)
		|	JSONValue(indent)
		|	DurationValue(indent)
		),

	UnknownValue :indent =
		(	Field
		|	Bind
		|	Null
		|	Cast(indent)
		|	NestedIndent(indent):nestedIndent
			SelectQuery(nestedIndent):query
			-> ('(' + nestedIndent + query + indent + ')')
		),

	Field =
			ReferencedField
		|	UnreferencedField,

	UnreferencedField =
		[	'Field'
			:field
		]
		-> ('"' + field + '"'),

	ReferencedField =
		[	'ReferencedField'
			:table
			:field
		]
		-> ('"' + table + '"."' + field + '"'),

	Bind =
		[	'Bind'
			(	number
			|	:tableName
				:field
				-> [tableName, field]
			):bind
		]
		{this.fieldOrderings.push(['Bind', bind])}
		-> '?',

	Null =
		:next
		?(next===null)
		-> 'NULL',

	Cast :indent =
		[	'Cast'
			AnyValue(indent):v
			DataType:type
		]
		-> ('CAST(' + v + ' AS ' + type + ')'),

	DataType =
		:typeName
		?sbvrTypes[typeName]
		?sbvrTypes[typeName].types[this.engine]
		{sbvrTypes[typeName].types[this.engine]}:dbType
		(	?(_.isFunction(dbType) || dbType.toUpperCase() === 'SERIAL')
			// HACK: SERIAL type in postgres is really an INTEGER with automatic sequence,
			// so it's not actually possible to cast to SERIAL, instead you have to cast to INTEGER.
			// For mysql/websql it's a function since it needs to generate an INTEGER ... AUTOINCREMENT/AUTO_INCREMENT
			-> 'INTEGER'
		|	-> dbType
		)
	,

	TextValue :indent =
		(	UnknownValue(indent)
		|	Text
		|	Concat(indent)
		|	Lower(indent)
		|	Upper(indent)
		|	Trim(indent)
		|	Replace(indent)
		|	Substring(indent)
		|	Right(indent)
		),

	Text =
		[	(	'Value'
			|	'Text'
			)
			:text
		]
		{this.fieldOrderings.push(['Text', text])}
		-> '?',

	Concat :indent =
		[	(	'Concat'
			|	'Concatenate'
			)
			TextValue(indent)+:comparators
		]
		(	?(this.engine == 'mysql')
			-> ('CONCAT(' + comparators.join(', ') + ')')
		|	-> ('(' + comparators.join(' || ') + ')')
		),

	Lower :indent =
		[	'Lower'
			TextValue(indent):string
		]
		-> ('LOWER(' + string + ')'),

	Upper :indent =
		[	'Upper'
			TextValue(indent):string
		]
		-> ('UPPER(' + string + ')'),

	Trim :indent =
		[	'Trim'
			TextValue(indent):string
		]
		-> ('TRIM(' + string + ')'),

	Replace :indent =
		[	'Replace'
			TextValue(indent):string
			TextValue(indent):find
			TextValue(indent):replacement
		]
		-> ('REPLACE(' + string + ', ' + find + ', ' + replacement + ')'),

	Substring :indent =
		[	'Substring'
			TextValue:string
			NumericValue+:args
		]
		-> ('SUBSTRING(' + [string].concat(args).join(', ') + ')'),

	Right :indent =
		[	'Right'
			TextValue:string
			NumericValue:n
		]
		(	?(this.engine == 'websql')
			-> ('SUBSTRING(' + string + ', -' + n + ')')
		|	-> ('RIGHT(' + string + ', ' + n + ')')
		),

	NumericValue :indent =
		(	UnknownValue(indent)
		|	Number
		|	MathOp(indent)
		|	BitwiseAnd(indent)
		|	BitwiseShiftRight(indent)
		|	CharacterLength(indent)
		|	StrPos(indent)
		|	ExtractNumericDatePart(indent)
		|	TotalSeconds(indent)
		|	Round(indent)
		|	Floor(indent)
		|	Ceiling(indent)
		),

	// TODO: Integer should actually be separate from number, for the case of bitwise operations that need an integral type.
	Number =
		[	(	'Number'
			|	'Real'
			|	'Integer'
			)
			number:number
		]
		-> number,

	MathOp :indent =
		[	(	'Add'
				-> '+'
			|	'Subtract'
				-> '-'
			|	'Multiply'
				-> '*'
			|	'Divide'
				-> '/'
			):op
			NumericValue(indent):lhs
			NumericValue(indent):rhs
		]
		-> [lhs, op, rhs].join(' '),

	BitwiseAnd :indent =
		[	'BitwiseAnd'
			NumericValue(indent):operand
			NumericValue(indent):mask
		]
		-> ('(' + operand + ' & ' + mask + ')'),

	BitwiseShiftRight :indent =
		[	'BitwiseShiftRight'
			NumericValue(indent):operand
			NumericValue(indent):shift
		]
		-> ('(' + operand + ' >> ' + shift + ')'),

	CharacterLength :indent =
		[	'CharacterLength'
			TextValue(indent):text
		]
		(	?(this.engine == 'mysql')
			-> ('CHAR_LENGTH(' + text + ')')
		|	-> ('LENGTH(' + text + ')')
		),

	StrPos :indent =
		[	'StrPos'
			TextValue:haystack
			TextValue:needle
		]
		(	?(this.engine == 'postgres')
			-> ('STRPOS(' + haystack + ', ' + needle + ')')
		|	-> ('INSTR(' + haystack + ', ' + needle + ')')
		),

	ExtractNumericDatePart :indent =
		[	(	'Year'
			|	'Month'
			|	'Day'
			|	'Hour'
			|	'Minute'
			|	'Second'
			|	'Fractionalseconds'
			):part
			DateValue:date
		]
		(	?(this.engine == 'websql')
			-> websqlDateFormats[part](date)
		|	-> dateFormats[part](date)
		),

	TotalSeconds :indent =
		[	'Totalseconds'
			DurationValue(indent):duration
		]
		(	?(this.engine == 'postgres')
			-> ('EXTRACT(EPOCH FROM ' + duration + ')')
		|	?(this.engine == 'mysql')
			-> ('(TIMESTAMPDIFF(MICROSECOND, FROM_UNIXTIME(0), FROM_UNIXTIME(0) + ' + duration + ') / 1000000)')
		|	{throw new Error('TotalSeconds not supported on: ' + this.engine)}
		),

	Round :indent =
		[	'Round'
			NumericValue:num
		]
		-> ('ROUND(' + num + ')'),

	Floor :indent =
		[	'Floor'
			NumericValue:num
		]
		-> ('FLOOR(' + num + ')'),

	Ceiling :indent =
		[	'Ceiling'
			NumericValue:num
		]
		-> ('CEILING(' + num + ')'),

	BooleanValue :indent =
		(	UnknownValue(indent)
		|	Boolean
		|	And(indent)
		|	Not(indent)
		|	Or(indent)
		|	Exists(indent)
		|	NotExists(indent)
		|	Comparison(indent)
		|	Between(indent)
		|	In(indent)
		|	NotIn(indent)
		),

	Boolean =
		[	'Boolean'
			(	true
				-> 1
			|	false
				-> 0
			):bool
		]
		-> bool,

	Not :indent =
		[	'Not'
			NestedIndent(indent):nestedIndent
			BooleanValue(nestedIndent):bool
		]
		-> ('NOT (' + nestedIndent + bool + indent + ')'),

	And :indent =
		[	'And'
			BooleanValue(indent)*:bools
		]
		-> bools.join(indent + 'AND '),

	Or :indent =
		[	'Or'
			BooleanValue(indent)*:bools
		]
		-> ('(' + bools.join(indent + 'OR ') + ')'),

	Exists :indent =
		[	'Exists'
			(	// We need to create a SelectQuery differently to other comparators, so we check for it first.
				NestedIndent(indent):nestedIndent
				SelectQuery(nestedIndent):ruleBody
				-> ('EXISTS (' + nestedIndent + ruleBody + indent + ')')
			|	AnyValue(indent):comparator
				-> (comparator + ' IS NOT NULL')
			):exists
		]
		-> exists,

	NotExists :indent =
		[	'NotExists'
			(	// We need to create a SelectQuery differently to other comparators, so we check for it first.
				NestedIndent(indent):nestedIndent
				SelectQuery(nestedIndent):ruleBody
				-> ('NOT EXISTS (' + nestedIndent + ruleBody + indent + ')')
			|	AnyValue(indent):comparator
				-> (comparator + ' IS NULL')
			):exists
		]
		-> exists,

	Comparison :indent =
		[	(	'Equals'
			|	'GreaterThan'
			|	'GreaterThanOrEqual'
			|	'LessThan'
			|	'LessThanOrEqual'
			|	'NotEquals'
			|	'Like'
			):comparison
			AnyValue(indent):a
			AnyValue(indent):b
		]
		-> (a + comparisons[comparison] + b),

	Between :indent =
		[	'Between'
			AnyValue(indent):val
			AnyValue(indent):a
			AnyValue(indent):b
		]
		-> (val + ' BETWEEN ' + a + ' AND ' + b),

	In :indent =
		[	'In'
			Field:field
			AnyValue(indent)+:vals
		]
		-> (field + ' IN (' + vals.join(', ') + ')'),

	NotIn :indent =
		[	'NotIn'
			Field:field
			AnyValue(indent)+:vals
		]
		-> (field + ' NOT IN (' + vals.join(', ') + ')'),

	DateValue :indent =
		(	UnknownValue(indent)
		|	Date(indent)
		|	ToDate(indent)
		|	ToTime(indent)
		|	Now(indent)
		),

	Date :indent =
		[	'Date'
			anything:date
		]
		{this.fieldOrderings.push(['Date', date])}
		-> '?',

	ToDate :indent =
		[	'ToDate'
			DateValue:date
		]
		-> ('DATE(' + date + ')'),

	ToTime :indent =
		[	'ToTime'
			DateValue:date
		]
		(	?(this.engine == 'postgres')
			-> ('CAST(' + date + ' AS TIME)')
		|	-> ('TIME(' + date + ')')
		),

	Now :indent =
		['Now']
		-> 'CURRENT_TIMESTAMP',

	JSONValue :indent =
		(	UnknownValue(indent)
		|	AggregateJSON(indent)
		),

	AggregateJSON :indent =
		[	'AggregateJSON'
			[	:table
				(	'*'
				|	anything:field
					-> ('"' + field + '"')
				):field
			]
		]
		{'"' + table + '".' + field}:field
		(	?(this.engine == 'postgres')
			-> ('coalesce(array_to_json(array_agg(' + field + ")), '[]')")
		|	{throw new Error('AggregateJSON not supported on: ' + this.engine)}
			// -> ("'[' || group_concat(" + field + ", ',') || ']'")
		),

	DurationValue :indent =
		(	UnknownValue(indent)
		|	Duration(indent)
		),

	Duration :indent =
		[	'Duration'
			anything:duration
		]
		?_.isObject(duration)
		{	_(duration)
			.pick('negative', 'day', 'hour', 'minute', 'second')
			.omitBy(_.isNil)
			.value()
		}:duration
		?(!_(duration).omit('negative').isEmpty())
		(	?(this.engine == 'websql')
			{throw new Error('Durations not supported on: ' + this.engine)}
		|	-> (
				"INTERVAL '" +
				(duration.negative ? '-' : '') +
				(duration.day || '0') +
				' ' +
				(duration.negative ? '-' : '') +
				(duration.hour || '0') + ':' +
				(duration.minute || '0') + ':' +
				// Force seconds to be at least 0.0 - required for mysql
				Number(duration.second).toLocaleString('en', { minimumFractionDigits: 1 }) +
				"'" +
				(this.engine == 'mysql' ? ' DAY_MICROSECOND' : '')
			)
		),

	Process :namespace =
			{this.fieldOrderings = []}
			{this.namespace = namespace || null}
			(	SelectQuery('\n')
			|	InsertQuery('\n')
			|	UpdateQuery('\n')
			|	DeleteQuery('\n')
			):query
			-> {query: query, bindings: this.fieldOrderings}
		|	UpsertQuery('\n')
		|	AnyValue('\n'):value
			-> ({ query: 'SELECT ' + value + ' AS "result";', bindings: this.fieldOrderings })
}
